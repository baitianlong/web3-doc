# ERC-1155 多代币标准

ERC-1155 是一种多代币标准，支持同一合约下同时管理同质化（FT）和非同质化（NFT）资产，广泛应用于游戏、元宇宙等场景。

## 标准简介

- ERC-1155 由 Enjin 团队提出，编号为 [EIP-1155](https://eips.ethereum.org/EIPS/eip-1155)
- 支持批量转账、批量授权、灵活的元数据

## 接口定义

```solidity
interface IERC1155 {
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    function balanceOf(address account, uint256 id) external view returns (uint256);
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address account, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}
```

## 主要函数说明

- `balanceOf`/`balanceOfBatch`：查询单个/批量账户的代币余额
- `setApprovalForAll`/`isApprovedForAll`：批量授权/查询授权
- `safeTransferFrom`/`safeBatchTransferFrom`：单个/批量安全转账

## 实战案例：最简 ERC-1155 实现

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleERC1155 {
    mapping(uint256 => mapping(address => uint256)) public balanceOf;
    mapping(address => mapping(address => bool)) public isApprovedForAll;
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    function mint(address to, uint256 id, uint256 amount) public {
        balanceOf[id][to] += amount;
        emit TransferSingle(msg.sender, address(0), to, id, amount);
    }

    function setApprovalForAll(address operator, bool approved) public {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata) public {
        require(from == msg.sender || isApprovedForAll[from][msg.sender], "Not authorized");
        require(balanceOf[id][from] >= amount, "Insufficient balance");
        balanceOf[id][from] -= amount;
        balanceOf[id][to] += amount;
        emit TransferSingle(msg.sender, from, to, id, amount);
    }
}
```

## 关键点说明

- 支持同一合约下多种资产（FT/NFT）
- 批量操作提升效率，节省 Gas
- 建议使用 OpenZeppelin 的 ERC1155 实现，支持元数据、批量铸造等
- 事件参数加 indexed，便于检索

## 最佳实践

- 遵循标准接口，确保钱包、市场兼容
- 合理设计 id 与元数据映射
- 生产环境建议用 OpenZeppelin ERC1155
- 注意安全性和授权管理

---

## 下一步操作

1. **动手实践**：用 OpenZeppelin 部署一个多资产合约。
2. **进阶挑战**：实现批量铸造、销毁、元数据扩展等功能。
3. **深入阅读**：
   - [EIP-1155 标准](https://eips.ethereum.org/EIPS/eip-1155)
   - [OpenZeppelin ERC1155 文档](https://docs.openzeppelin.com/contracts/4.x/api/token/erc1155) 