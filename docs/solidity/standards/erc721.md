# ERC-721 NFT 标准

ERC-721 是以太坊上最流行的非同质化代币（NFT）标准，适用于数字藏品、游戏资产、门票等唯一性资产。

## 标准简介

- ERC-721 由以太坊社区提出，编号为 [EIP-721](https://eips.ethereum.org/EIPS/eip-721)
- 适用于不可分割、唯一的数字资产

## 接口定义

```solidity
interface IERC721 {
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
}
```

## 主要函数说明

- `balanceOf(address)`：查询地址拥有的 NFT 数量
- `ownerOf(tokenId)`：查询 NFT 所有者
- `transferFrom/safeTransferFrom`：转移 NFT 所有权
- `approve/setApprovalForAll`：授权他人管理 NFT
- `getApproved/isApprovedForAll`：查询授权状态

## 实战案例：最简 ERC-721 实现

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleERC721 {
    string public name = "DemoNFT";
    string public symbol = "DNFT";
    mapping(uint256 => address) public ownerOf;
    mapping(address => uint256) public balanceOf;
    mapping(uint256 => address) public getApproved;
    mapping(address => mapping(address => bool)) public isApprovedForAll;
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function mint(address to, uint256 tokenId) public {
        require(ownerOf[tokenId] == address(0), "Token already minted");
        ownerOf[tokenId] = to;
        balanceOf[to] += 1;
        emit Transfer(address(0), to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(ownerOf[tokenId] == from, "Not owner");
        require(msg.sender == from || msg.sender == getApproved[tokenId] || isApprovedForAll[from][msg.sender], "Not approved");
        ownerOf[tokenId] = to;
        balanceOf[from] -= 1;
        balanceOf[to] += 1;
        emit Transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf[tokenId];
        require(msg.sender == owner, "Not owner");
        getApproved[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function setApprovalForAll(address operator, bool approved) public {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
}
```

## 关键点说明

- Transfer、Approval、ApprovalForAll 事件必须实现
- 建议使用 OpenZeppelin 的 ERC721 实现，支持元数据、可扩展性更好
- safeTransferFrom 支持合约接收 NFT，防止 NFT 丢失
- NFT 通常配合元数据（如 tokenURI）和 IPFS 使用

## 最佳实践

- 遵循标准接口，确保钱包、市场兼容
- 事件参数加 indexed，便于检索
- 生产环境建议用 OpenZeppelin ERC721
- 合理设计 tokenId 生成和元数据存储方案

---

## 下一步操作

1. **动手实践**：用 OpenZeppelin 部署一个自定义 NFT 合约。
2. **进阶挑战**：实现带元数据、批量铸造等扩展功能。
3. **深入阅读**：
   - [EIP-721 标准](https://eips.ethereum.org/EIPS/eip-721)
   - [OpenZeppelin ERC721 文档](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721) 